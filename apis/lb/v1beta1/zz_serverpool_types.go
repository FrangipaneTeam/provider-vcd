/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type MemberObservation struct {

	// The NSX ID of the load balancer server pool
	// Pool member id (formatted as member-xx, where xx is a number)
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type MemberParameters struct {

	// State of member in a pool. One of enabled, disabled, or drain. When member condition
	// is set to drain it stops taking new connections and calls, while it allows its sessions on existing connections to
	// continue until they naturally end. This allows to gracefully remove member node from load balancing rotation.
	// Defines member state. One of enabled, drain, disabled.
	// +kubebuilder:validation:Required
	Condition *string `json:"condition" tf:"condition,omitempty"`

	// Member IP address
	// IP address of member in server pool
	// +kubebuilder:validation:Required
	IPAddress *string `json:"ipAddress" tf:"ip_address,omitempty"`

	// The maximum number of concurrent connections the member can handle. Note: when the
	// number of incoming requests exceeds the maximum, requests are queued and the load balancer waits for a connection to be
	// released.
	// The maximum number of concurrent connections the member can handle. If exceeded requests are queued and the load balancer waits for a connection to be released
	// +kubebuilder:validation:Optional
	MaxConnections *float64 `json:"maxConnections,omitempty" tf:"max_connections,omitempty"`

	// The minimum number of concurrent connections a member must always accept.
	// Minimum number of concurrent connections a member must always accept
	// +kubebuilder:validation:Optional
	MinConnections *float64 `json:"minConnections,omitempty" tf:"min_connections,omitempty"`

	// Monitor Port at which the member is to receive health monitor requests. Note: can
	// be the same as port
	// Port at which the member is to receive health monitor requests. Can be the same as port
	// +kubebuilder:validation:Required
	MonitorPort *float64 `json:"monitorPort" tf:"monitor_port,omitempty"`

	// Server Pool name
	// Name of pool member
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// The port at which the member is to receive traffic from the load balancer.
	// Port at which the member is to receive traffic from the load balancer
	// +kubebuilder:validation:Required
	Port *float64 `json:"port" tf:"port,omitempty"`

	// The proportion of traffic this member is to handle. Must be an integer in the range 1-256.
	// Proportion of traffic this member is to handle. Must be an integer in the range 1-256
	// +kubebuilder:validation:Required
	Weight *float64 `json:"weight" tf:"weight,omitempty"`
}

type ServerPoolObservation struct {

	// The NSX ID of the load balancer server pool
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// A block to define server pool members. Multiple can be used. See Member and
	// example for usage details.
	// +kubebuilder:validation:Optional
	Member []MemberObservation `json:"member,omitempty" tf:"member,omitempty"`
}

type ServerPoolParameters struct {

	// Server Pool load balancing method. Can be one of ip-hash, round-robin, uri, leastconn, url, or httpheader
	// Balancing method for the service. One of 'ip-hash', 'round-robin', 'uri', 'leastconn', 'url', or 'httpheader'
	// +kubebuilder:validation:Required
	Algorithm *string `json:"algorithm" tf:"algorithm,omitempty"`

	// Valid only when algorithm is httpheader or url. The httpheader algorithm
	// parameter has one option headerName=<name> while the url algorithm parameter has option urlParam=<url>.
	// Additional options for load balancing algorithm for httpheader or url algorithms
	// +kubebuilder:validation:Optional
	AlgorithmParameters *string `json:"algorithmParameters,omitempty" tf:"algorithm_parameters,omitempty"`

	// Server Pool description
	// Server pool description
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The name of the edge gateway on which the server pool is to be created
	// Edge gateway name in which the LB Server Pool is located
	// +crossplane:generate:reference:type=github.com/FrangipaneTeam/provider-vcd/apis/edgegateway/v1beta1.EdgeGateway
	// +kubebuilder:validation:Optional
	EdgeGateway *string `json:"edgeGateway,omitempty" tf:"edge_gateway,omitempty"`

	// Reference to a EdgeGateway in edgegateway to populate edgeGateway.
	// +kubebuilder:validation:Optional
	EdgeGatewayRef *v1.Reference `json:"edgeGatewayRef,omitempty" tf:"-"`

	// Selector for a EdgeGateway in edgegateway to populate edgeGateway.
	// +kubebuilder:validation:Optional
	EdgeGatewaySelector *v1.Selector `json:"edgeGatewaySelector,omitempty" tf:"-"`

	// When transparency is false (default) backend servers see the IP address of the
	// traffic source as the internal IP address of the load balancer. When it is true the source IP address is the actual IP
	// address of the client and the edge gateway must be set as the default gateway to ensure that return packets go through
	// the edge gateway.
	// Makes client IP addresses visible to the backend servers
	// +kubebuilder:validation:Optional
	EnableTransparency *bool `json:"enableTransparency,omitempty" tf:"enable_transparency,omitempty"`

	// A block to define server pool members. Multiple can be used. See Member and
	// example for usage details.
	// +kubebuilder:validation:Optional
	Member []MemberParameters `json:"member,omitempty" tf:"member,omitempty"`

	// vcd_lb_service_monitor resource id to attach to server pool for health check parameters
	// Load Balancer Service Monitor ID
	// +kubebuilder:validation:Optional
	MonitorID *string `json:"monitorId,omitempty" tf:"monitor_id,omitempty"`

	// The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organisations
	// The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organizations
	// +kubebuilder:validation:Optional
	Org *string `json:"org,omitempty" tf:"org,omitempty"`

	// The name of VDC to use, optional if defined at provider level
	// The name of VDC to use, optional if defined at provider level
	// +kubebuilder:validation:Optional
	Vdc *string `json:"vdc,omitempty" tf:"vdc,omitempty"`
}

// ServerPoolSpec defines the desired state of ServerPool
type ServerPoolSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ServerPoolParameters `json:"forProvider"`
}

// ServerPoolStatus defines the observed state of ServerPool.
type ServerPoolStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ServerPoolObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// ServerPool is the Schema for the ServerPools API. Provides an NSX edge gateway load balancer server pool resource.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,vcd}
type ServerPool struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ServerPoolSpec   `json:"spec"`
	Status            ServerPoolStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ServerPoolList contains a list of ServerPools
type ServerPoolList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ServerPool `json:"items"`
}

// Repository type metadata.
var (
	ServerPool_Kind             = "ServerPool"
	ServerPool_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ServerPool_Kind}.String()
	ServerPool_KindAPIVersion   = ServerPool_Kind + "." + CRDGroupVersion.String()
	ServerPool_GroupVersionKind = CRDGroupVersion.WithKind(ServerPool_Kind)
)

func init() {
	SchemeBuilder.Register(&ServerPool{}, &ServerPoolList{})
}
